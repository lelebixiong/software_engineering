## Q1:在处理大型软件系统时，主要的问题是什么?
👉 主要问题是 **复杂性（complexity）**。  
当软件系统规模很大时，代码量、模块数量、人员协作和需求都会快速增长，导致
- 代码之间的交互关系变得难以追踪。
- 系统容易出现 bug 和不可预测的行为。
- 维护和扩展的成本大幅上升。

## Q2:如果一个程序有N行代码，代码行之间可能有多少种不同的交互
👉 可能的交互数大约是 **N × (N - 1) / 2**（即两两之间的组合）。  
因为每一行代码都可能和其他行发生交互（依赖、调用、影响），交互数量不是线性的，而是近似平方级别。  
这也是为什么随着代码行数增加，复杂性会急剧上升。


## Q3:当使用结构化编程语言（不是汇编语言）时，该语言的哪些特性可以帮助您减少代码行之间的交互次数？
👉 结构化编程语言提供的主要特性是 **模块化与控制结构（如函数、过程、if/else、循环）**。  
它们可以：
- 把代码分成逻辑单元（函数/方法），减少全局交互。
- 限制 “goto” 式的无序跳转，从而降低不可控的交互。

## Q4:Java™语言的OO编程、作用域和可访问性特性如何帮助您降低复杂性?
👉 面向对象（OO）、作用域（scope）和可见性（accessibility）在 Java 里帮助降低复杂性：

- **封装（Encapsulation）**：类把数据和方法绑定在一起，内部实现细节对外隐藏。
- **作用域（Scope）**：局部变量、类变量、方法作用域让变量不会随意被其他地方访问。
- **访问控制（Accessibility）**：`private`、`protected`、`public` 等关键字限制谁能访问某些方法/属性，从而减少不必要的依赖。  
    结果就是：模块之间耦合度降低，交互减少，复杂性下降。

## Q5：软件过程（software process）的主要特征

软件过程就是把“要做什么”转化为“如何做”的一系列活动的有序集合。主要特征可以归纳为：
- **一组活动（Activities）**：常见活动包括需求获取/分析、规格说明、设计、实现（编码）、测试、部署、维护与演化。
    
- **输入与输出（Artifacts）**：每个活动产生文档或产物，比如需求规格、设计文档、源代码、测试用例、用户手册等。
    
- **角色与职责（Roles）**：不同角色（产品经理/需求工程师、架构师、开发者、测试工程师、运维、项目经理等）在过程里分工明确。
    
- **控制与管理（Project management）**：进度计划、里程碑、资源分配、风险管理、配置管理。
    
- **方法与技术（Methods & Tools）**：可用不同模型（瀑布、迭代、增量、敏捷/Scrum、DevOps），并借助工具（版本控制、CI/CD、缺陷跟踪）。
    
- **质量保证（QA）与度量（Measurement）**：代码评审、自动化测试、度量指标（缺陷率、覆盖率、交付频率等）。
    
- **可重复性与改进（Process improvement）**：过程应可重复、可衡量，并能通过反馈持续改进（如 CMMI、ISO、持续改进）。
    
- **反馈与迭代**：现代过程强调快速反馈、短周期迭代，尽早验证假设并调整方向

Q6：软件规格（specification）与设计（design）之间的关系
- **“什么”（Specification / Requirements） vs “如何”（Design）**
    
    - 规格说明描述系统**应做什么**：功能性需求（功能、输入/输出、业务规则）和非功能性需求（性能、安全、可靠性、可用性等）。规格应当可验证、无歧义。
        
    - 设计描述**如何实现这些需求**：系统架构、模块划分、接口、数据结构、算法、技术选型、部署方案等。
        
- **输入/输出关系**：规格是设计的**主要输入**。设计应当映射并满足规格中的每一项（追踪性）。
    
- **抽象层次不同**：规格通常较抽象、面向业务或用户；设计更具体、技术实现导向。
    
- **可追溯性（Traceability）**：良好工程实践要求从需求到设计到实现到测试形成追踪链，便于变更管理与验证。
    
- **变更影响**：规格变更会直接影响设计（甚至实现）；因此需要变更控制和影响分析。
    
- **测试的桥梁**：规格为测试提供验收标准（acceptance criteria）；设计为单元/集成测试提供边界与接口信息。
    
**举例**：规格：用户必须能用邮箱登录（功能需求）；设计：选择 OAuth2 或自建认证模块、密码存储算法、前端与后端接口等（实现细节）。

**要点**：规格告诉你要做什么，设计告诉你怎么做；二者必须保持一致并且可追踪。

## Q7：为什么在测试时规格很重要？
- **测试用例来自规格**：好的测试用例应直接依据需求/规格写出（包括正向场景、边界条件、异常情况、非功能要求）。没有清晰规格，测试就没有“判定标准”（oracle）。
    
- **可验证性**：规格为“是否满足需求”提供明确判别标准（验收标准），测试才能判断通过/失败。
    
- **覆盖性与追踪性**：通过需求-测试用例的映射，可以衡量测试覆盖率（哪些需求已被测试、哪些未被测试）。
    
- **减少歧义和偏差**：模糊或不完整的规格会导致测试缺失或测试针对错误的行为，从而漏掉缺陷或错判实现。
    
- **提前设计测试（Test early）**：若在规格阶段就考虑可测试性（可验收标准、示例），能在设计和实现早期发现问题（Shift-left）。
    
- **回归/验收**：当需求演化时，规格变更指导哪些测试需要更新或重跑。
    
- **非功能测试依据**：性能、安全等非功能测试需要明确的数值或约束（例如响应时间 < 200ms），这些都源于规格。

Q8：SCRUM 术语逐项解释：
a. **Product Backlog（产品待办列表）**

- 产品所有需求、功能、缺陷、技术债等的优先级清单。通常由**Product Owner（产品负责人）**维护并按价值/优先级排序（最有价值的项靠前）。
    
- 形式通常是 user stories、epics、bug、技术任务等。
    

b. **Daily Scrum（每日站会 / 日会）**

- 团队成员每天进行的短会（建议 15 分钟），目的是同步进展、计划当天工作、暴露阻碍。不是管理回报会，而是开发团队的自组织同步。一般回答三件事：昨天做了什么、今天计划做什么、有什么阻碍。
    

c. **Scrum Master（Scrum 主）**

- Scrum 流程的推动者与教练，负责删除团队阻碍、帮助团队遵守 Scrum 实践、促进持续改进。**不是传统管理者**（不直接分配任务），而是服务型领导（servant leader）。
    

d. **Sprint（冲刺 / 迭代）**

- 一个固定时长的开发周期（通常 1–4 周），在每个 Sprint 结束时交付一个“可用的增量”（Potentially shippable increment）。Sprint 期间目标固定（尽量不变动），团队围绕 Sprint Goal 工作。
    

e. **Time box（时间盒 / 定时约束）**

- 将活动限定在固定时间内完成（例如 Sprint 本身是一个 time box，Sprint Planning、Daily Scrum、Sprint Review、Sprint Retrospective 也是时间盒）。时间盒帮助约束范围并促使决策。
    

f. **Stakeholders（干系人 / 利益相关者）**

- 对产品有利益关系或影响的人：用户、客户、业务代表、市场、法律、运营团队等。干系人在 Sprint Review 等活动中提供反馈。
    

g. **Sprint Burndown（冲刺燃尽图）**

- 展示 Sprint 中剩余工作量（通常以小时或故事点计）随时间下降的图表。用于监控进度、发现偏差。燃尽图下降越接近理想线越好；若平坦说明进展慢，若上升说明添加/重估工作。
    

h. **Sprint Backlog（冲刺待办列表）**

- 从 Product Backlog 中挑选出来、计划在当前 Sprint 完成的条目集合，配合为实现这些条目所需的任务分解。由开发团队拥有和维护。
    

i. **Sprint Planning（冲刺计划会）**

- Sprint 开始时的计划会议：确定 Sprint Goal，从 Product Backlog 中选取要做的项（即 Sprint Backlog），并估算/拆分任务，形成可执行计划。参与者：Product Owner、Scrum Master、开发团队。

## Q9：“Inventory loss”（库存损失）概念与如何通过优先级降低损失
**概念**：软件工程中的 “inventory loss” 指的是把某些功能按规格与产品实现了，但这些功能最终被发现对客户/用户**没有用**或**不被采用**，导致时间、人力和机会成本的浪费。类似实体库存的积压——功能实现了但没有产生价值。

### 优先化功能并先做高优先级项如何降低 inventory loss

关键思想：**先交付最有价值、风险最高或验证性强的功能**，尽早把假设放到市场/用户面前验证，从而**尽早发现无用功能并停止开发**，减少浪费。

**机制细节**：

1. **价值驱动的顺序**：按业务价值或客户价值排序（Product Backlog 优先级），先实现高价值项。若高价值项满足用户需要，则说明方向对；若不行，及时调整。
    
2. **快速交付与验证（短迭代）**：以小步快跑（Sprint、MVP）交付可验证增量，获取真实用户反馈。
    
3. **最小可行产品（MVP）与试验**：对不确定的功能先做 MVP 或 A/B 测试，验证后再扩展。
    
4. **度量与数据驱动决策**：用用户行为、使用率、转化率等指标判断功能价值，决定是否继续投资。
    
5. **优先级方法论**：用 MoSCoW（Must/Should/Could/Won’t）、Kano 模型、WSJF（加权最短作业优先）等方法量化优先级，把“高价值/短周期/低不确定性”的项优先做。
    
6. **减少在制品（WIP）**：限制并行开发的功能数，降低多头投入导致的资源浪费。
    
7. **Feature toggles（特性开关）**：先实现后隐藏，先验证再公开，降低不可逆损失。
