1.
	**SVN (Subversion)**：集中式版本控制系统（比较旧），适合线性工作流。 
	**Git**：分布式版本控制系统，现在最流行，支持分支/合并、分布式协作（GitHub/GitLab）。 
	**JUnit**：Java 的单元测试框架，用于编写和运行自动化测试。 
	**Eclipse**：流行的 Java IDE（也支持其它语言），有丰富插件生态。 

2.final ketword
	**final 变量（局部变量或属性）**：一旦赋值不可再改变。对于引用类型，引用地址不可变，但对象内容可变（除非该对象自身不可变）。可以有“blank final”（延迟赋值一次）或 `static final`（常量） 
	**final 方法**：不能被子类重写（override）。常用于防止改变关键行为或确保安全 
	**final 类**：不能被继承（不能有子类）。常见例子 `java.lang.String `
3.接口（interface):
	interface Flyable {  
	    void fly(); 
	    default void land() { System.out.println("landing"); } 
	} 
4.抽象类（abstract class）:
	abstract class Animal { 
	    String name; 
	    Animal(String n){ this.name = n; } 
	    abstract void makeSound(); 
	    void eat(){ System.out.println("eat"); 
	     } 
5.具体类（concrete class)：
完整实现，可以实例化。可能实现接口或继承抽象类
	class Dog extends Animal { 
	    Dog(String n){ super(n); } 
	    void makeSound(){ System.out.println("woof"); } 
	} 




## Q1:描述软件生命周期（SDLC）过程：

 1. **需求工程（Requirements）**
    - 活动：需求获取、需求分析、编写需求规格说明书（SRS）、利益相关者确认。
    - 产出：功能/非功能需求、用例、用户故事。
        
2. **系统/架构设计（System & Architecture Design）**
    - 活动：划分模块、定义接口、选择技术栈、设计高层架构（组件、部署、数据流）。
    - 产出：架构图、API 设计、数据库 ER 图、接口规范。
        
3. **详细设计（Detailed Design）**
    - 活动：模块内部设计、类设计、算法选择、数据结构定义。
    - 产出：类图、顺序图、伪代码、设计文档。
        
4. **实现/编码（Implementation）**
    - 活动：实际编码、代码复审、单元测试、持续集成。
    - 产出：可运行代码、单元测试套件。
        
5. **测试（Verification & Validation）**
    - 活动：集成测试、系统测试、验收测试、性能/安全测试、回归测试。
    - 产出：测试报告、缺陷列表。
        
6. **部署（Deployment）**
    - 活动：上线、配置、发布、部署自动化（CI/CD）。
    - 产出：生产环境可用系统、部署脚本。
        
7. **运维与维护（Operation & Maintenance）**
    - 活动：监控、修 bug、功能迭代、性能调优。
    - 产出：补丁、升级、运维手册。
    
**其他常见模型**：
- **瀑布模型**（顺序执行），适合需求稳定的项目。
- **迭代/增量与敏捷（Agile）**：短迭代、持续交付，强调客户反馈。
- **V 模型**：把测试与开发阶段成对对齐（单元->集成->系统测试）。
- **DevOps**：把开发与运维合并，强调 CI/CD、自动化部署与监控

## Q2：coupling(耦合), cohesion(内聚) and encapsulation(封装)的重要性

- **Cohesion（内聚性）**：表示模块内部功能的一致性。**高内聚**意味着模块内部的功能相互关联、职责单一。优点：易理解、易维护、可重用。
    - 例如：一个“用户认证”模块只处理登录/登出/权限，不处理订单逻辑 → 高内聚。
        
- **Coupling（耦合度）**：模块之间依赖的强度。**低耦合**意味着模块之间接口清晰、依赖少。优点：便于独立修改、测试与复用。
    - 技术手段：接口（abstraction）、依赖注入（DI）、消息/事件总线。
        
- **Encapsulation（封装）**：隐藏模块内部实现细节，只暴露必需接口。优点：降低复杂度，保护不变量，支持接口替换与单元测试（mock）。
    - 例如：把类的内部状态设为私有（private），通过 public 方法访问


## Q3:继承为什么有用

- **复用代码**：子类继承父类的实现，避免重复代码。
    
- **多态（Polymorphism）**：父类引用可以指向任意子类对象，便于编写通用代码（接口编程）。例如：`List<Animal>` 可存放 `Dog`/`Cat`，并调用共同接口方法。
    
- **组织层次结构**：表达“is-a”关系，便于抽象化建模（例如 `Vehicle` → `Car`/`Truck`）。
    
- **可扩展性**：通过继承和覆盖（override）可以改变或扩展行为。

## Q4:黑盒测试 vs 白盒测试
- **黑盒测试（Black-box testing）**：
    
    - 测试者只关注功能规格与输入输出，不关心内部实现。
    - 技术：功能测试、等价类划分、边界值分析、状态转换测试、系统/验收测试。
    - 优点：模拟用户视角，能发现需求与接口错误。
    - 缺点：可能覆盖不到实现细节，如特定语句路径。
        
- **白盒测试（White-box testing / Glass-box）**：
    
    - 测试者需要了解程序内部结构，编写测试以覆盖代码路径。
    - 技术：单元测试、语句覆盖、分支覆盖、条件覆盖、路径测试、静态分析。
    - 优点：能发现内部逻辑错误、边界条件与异常路径。
    - 缺点：对实现依赖强，不能检测遗漏的需求。


## Q5:如何确定 Petri 网的下一个状态
**Petri 网元素回顾**：

- **Places（库所）**：用圈表示，存放 token（标识符）。
- **Transitions（变迁）**：用方块/线表示，表示事件或动作。
- **Arcs（弧）**：连接 places ↔ transitions，可能有权重（weight）。
- **Marking（标识 / 状态）**：每个 place 上的 token 数量，记作向量 M
- Enabled(可触发)：若对 t 的每个输入库所 p，当前标识 M(p)满足 M(p)≥W(p,t)（输入弧权重），则 t可触发（enabled）

确定步骤：
- **列出所有变迁**，检查哪些变迁满足可触发条件（enabled）。
- **选取一个或多个可触发的变迁**（如果有并发，多个变迁可以并行触发，视模型规则而定）。
- **按触发规则更新标识**，得到新的 M′M'M′。
- **重复**以继续生成可达标识集合（reachability set）